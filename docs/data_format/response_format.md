# Datapresso 数据格式规范

## 1. 概述

Datapresso框架采用标准化的JSON数据格式，确保数据在各层之间流转时保持一致性和完整性。本文档详细说明了框架中使用的数据结构，特别是响应字段的三部分结构设计。

## 2. 基础数据结构

所有Datapresso数据样本必须遵循以下基础结构：

```json
{
  "id": "唯一标识符",
  "instruction": "指令文本",
  "response": {
    "origin_text": "原始响应文本",
    "rationale": "推理过程",
    "final_answer": "最终答案"
  },
  "metadata": {
    // 元数据字段，随着数据流转逐步丰富
  }
}
```

## 3. 响应字段三部分结构

### 3.1 设计原理

响应字段被分为三个独立部分，以支持更精细的评估和训练：

1. **origin_text**: 原始完整响应文本，保留原始数据的完整性
2. **rationale**: 详细的推理过程，展示解决问题的思考步骤
3. **final_answer**: 简洁的最终答案，直接回答问题

这种分离设计允许：
- 分别评估推理质量和答案准确性
- 针对不同任务调整推理与答案的权重
- 提高模型的可解释性和透明度
- 支持更精细的质量评估和筛选策略

### 3.2 字段详细说明

#### 3.2.1 origin_text

原始完整响应文本，通常包含推理过程和最终答案。

- **类型**: 字符串
- **必填**: 是
- **示例**: "要计算45乘以67，我们可以分步进行。首先，5×7=35，写下5，进3；4×7=28，加上进位的3得31，写下1，进3；5×6=30，加上进位的3得33，写下3，进3；4×6=24，加上进位的3得27，所以结果是3015。"

#### 3.2.2 rationale

详细的推理过程，展示解决问题的思考步骤。

- **类型**: 字符串
- **必填**: 是
- **示例**: "计算45乘以67，首先5×7=35，写下5，进3；4×7=28，加上进位的3得31，写下1，进3；5×6=30，加上进位的3得33，写下3，进3；4×6=24，加上进位的3得27，所以结果是3015。"

#### 3.2.3 final_answer

简洁的最终答案，直接回答问题。

- **类型**: 字符串
- **必填**: 是
- **示例**: "3015"

### 3.3 不同类型任务的示例

#### 3.3.1 数学计算

```json
{
  "instruction": "计算45乘以67的结果",
  "response": {
    "origin_text": "45乘以67等于3015",
    "rationale": "计算45乘以67，首先5×7=35，写下5，进3；4×7=28，加上进位的3得31，写下1，进3；5×6=30，加上进位的3得33，写下3，进3；4×6=24，加上进位的3得27，所以结果是3015。",
    "final_answer": "3015"
  }
}
```

#### 3.3.2 概念解释

```json
{
  "instruction": "解释量子纠缠的概念",
  "response": {
    "origin_text": "量子纠缠是量子力学中的一种现象...",
    "rationale": "量子纠缠是量子力学中的一种现象，当两个或多个粒子以某种方式相互作用或共同产生，使得它们的量子状态无法独立描述。即使这些粒子被分离到很远的距离，改变其中一个粒子的状态也会立即影响到另一个粒子的状态。这种现象被爱因斯坦称为'幽灵般的超距作用'，它挑战了经典物理学中的局域性原理。",
    "final_answer": "量子纠缠是指两个或多个粒子之间存在的一种特殊关联，使得一个粒子的状态改变会立即影响到另一个粒子，无论它们相距多远。"
  }
}
```

#### 3.3.3 代码生成

```json
{
  "instruction": "编写一个Python函数计算斐波那契数列的第n项",
  "response": {
    "origin_text": "以下是计算斐波那契数列第n项的Python函数...",
    "rationale": "斐波那契数列的定义是每一项等于前两项之和，初始值F(0)=0，F(1)=1。我们可以使用递归或迭代方法实现。递归方法简洁但效率低，迭代方法效率高。这里我选择迭代方法实现：首先处理特殊情况n=0和n=1，然后使用循环计算从第2项到第n项的值，每次保存前两项并计算当前项。",
    "final_answer": "```python\ndef fibonacci(n):\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b\n```"
  }
}
```

## 4. 元数据结构

元数据字段随着数据在Pipeline中流转逐步丰富，包含以下主要部分：

```json
"metadata": {
  "domain": "领域分类",
  "difficulty": 0.75,
  "source": "数据来源",
  "creation_timestamp": "2024-05-01T10:15:30Z",
  "generation": {
    // 生成相关信息
  },
  "evaluations": {
    // 评估相关信息，包括推理过程和最终答案的单独评分
  },
  "filtering": {
    // 筛选相关信息
  },
  "advanced_assessment": {
    // 高级评估相关信息
  }
}
```

## 5. 层间数据流转

数据在各层之间流转时，元数据会逐步丰富，但基础结构保持不变。特别是响应字段的三部分结构在整个流程中始终保持一致，确保各层可以分别评估和处理推理过程和最终答案。

## 6. 实现注意事项

- 所有层必须保持响应字段的三部分结构
- 评估指标应分别针对推理过程和最终答案
- 数据生成时应同时生成高质量的推理过程和准确的最终答案
- 数据筛选应考虑推理质量和答案准确性的平衡
- 训练时可以尝试不同的策略，如仅使用推理过程、仅使用最终答案或同时使用两者
- 评估时应分析推理质量与答案准确性之间的关系
